# Functions

Ever notice yourself writing the same code over and over? That's annoying, right?

For example, say you need to show a welcome message when someone logs in, when they log out, and a few other places too. Writing the same message code everywhere is tedious and wasteful.

Functions fix this problem. Think of them as reusable chunks of code that you can use anywhere in your program just by calling their name.

You've already used functions like `alert(message)`, `prompt(message, default)` and `confirm(question)`. Those are built into JavaScript. But you can also make your own!

## Creating a Function

To create your own function, use this pattern:

```js
function showMessage() {
  alert( 'Hello everyone!' );
}
```

Here's what's happening:
1. Start with the word `function`
2. Give it a name (like `showMessage`)
3. Add parentheses `()` - we'll put stuff in there later
4. Put your code inside curly braces `{}`

The basic pattern:
```js
function name(parameters) {
  ...your code here...
}
```

To use your function, just call it by name with parentheses:

```js run
function showMessage() {
  alert( 'Hello everyone!' );
}

*!*
showMessage();
showMessage();
*/!*
```

Calling `showMessage()` runs whatever code is inside. The example above shows the message twice.

The beauty of functions? If you want to change the message later, you only need to update it in ONE place - inside the function. Then everywhere you call it gets the new version automatically.

## Variables Inside Functions (Local Variables)

When you create a variable inside a function, it only exists inside that function. It's like a secret the function keeps to itself.

```js run
function showMessage() {
*!*
  let message = "Hello, I'm JavaScript!"; // only exists in here
*/!*

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- ERROR! message doesn't exist out here
```

## Using Variables From Outside (Outer Variables)

Functions can reach outside themselves to use variables that exist in the outer code:

```js run no-beautify
let *!*userName*/!* = 'John';

function showMessage() {
  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // Hello, John
```

The function can even change that outer variable:

```js run
let userName = 'John';

function showMessage() {
  userName = "Bob"; // changes the outer variable

  let message = 'Hello, ' + userName;
  alert(message);
}

alert( userName ); // *!*John*/!* before calling the function

showMessage();

alert( userName ); // *!*Bob*/!* - the function changed it!
```

But here's the catch: if you create a NEW variable inside the function with the same name, the function uses its own version and ignores the outer one:

```js run
let userName = 'John';

function showMessage() {

  let userName = "Bob"; // brand new variable, same name

  let message = 'Hello, ' + userName; // uses Bob
  alert(message);
}

showMessage(); // uses its own userName (Bob)

alert( userName ); // *!*John*/!* - the outer one is unchanged
```

```smart header="Global variables"
Variables created outside all functions are called *global* - they're accessible from anywhere.

You CAN use globals, but it's better to use them sparingly. Keep most of your variables inside functions where they belong. Globals are best for app-wide settings or data that truly needs to be everywhere.
```

## Passing Data to Functions (Parameters)

You can give functions information to work with by passing in *parameters* (also called *arguments*).

Here's a function that takes two pieces of info:

```js run
function showMessage(from, text) { // from and text are parameters
  alert(from + ': ' + text);
}

showMessage('Ann', 'Hello!'); // Ann: Hello!
showMessage('Ann', "What's up?"); // Ann: What's up? 

```

When you call the function, the values you pass in ('Ann' and 'Hello!') get copied into new variables inside the function.

Important: the function gets a COPY of the value, not the original. So if the function changes it, the original stays the same:

```js run
function showMessage(from, text) {
  from = '*' + from + '*'; // changes the copy

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// the original "from" is unchanged
alert( from ); // Ann
```

## Setting Backup Values (Default Parameters)

What if someone forgets to pass in all the info? The missing parameter becomes `undefined`.

```js
showMessage("Ann");
```

This would show `"Ann: undefined"` because there's no second value.

You can set a fallback value that kicks in when nothing is passed:

```js run
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

The default value can even be the result of calling another function:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() only runs if text wasn't provided
  // whatever it returns becomes the text value
}
```

```smart header="When default values are calculated"
JavaScript calculates default values fresh each time the function is called. 

In the example above, `anotherFunction()` runs every single time `showMessage()` is called without a `text` parameter. It doesn't just run once.
```


## Quick Recap

Basic function structure:

```js
function name(parameters, separated, by, commas) {
  /* your code */
}
```

Key things to remember:
- Values you pass to a function get copied into the function's own variables
- Functions can see and use variables from outside, but outside code can't see variables inside the function
- Functions can give back a result. If they don't return anything, the result is `undefined`

Functions are the building blocks of your programs. This is just the start - there's way more cool stuff functions can do, and we'll dive deeper into those features as we go.
